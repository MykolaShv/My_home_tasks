FETCH [ direction ] [ FROM | IN ] cursor_name
where direction can
be one of:
    NEXT
    PRIOR
    FIRST
    LAST
    ABSOLUTE count
    RELATIVE count
    count
    ALL
    FORWARD
    FORWARD count
    FORWARD ALL
    BACKWARD
    BACKWARD count
    BACKWARD ALL
Description
FETCH извлекает строки с помощью ранее созданного курсора.
У курсора есть связанная позиция, которая используется FETCH . Положение курсора может быть перед 
первой строкой результата запроса, в любой конкретной строке результата или после последней строки 
результата. При создании курсор располагается перед первой строкой. После получения нескольких строк
 курсор устанавливается на строку, полученную последней. Если FETCH запускается за конец доступных строк, 
то курсор остается после последней строки или перед первой строкой, если выполняется выборка назад.
 FETCH ALL или FETCH BACKWARD ALL всегда будет оставлять курсор после последней строки или перед первой 
строкой.
Формы NEXT , PRIOR уровень , FIRST , LAST , ABSOLUTE , RELATIVE принести одну строку после перемещения 
курсора соответствующим образом . Если такой строки нет, возвращается пустой результат, а курсор остается 
перед первой строкой или после последней строки, в зависимости от ситуации.
Формы, использующие FORWARD и BACKWARD , извлекают указанное количество строк, перемещающихся в прямом 
или обратном направлении, оставляя курсор на последней возвращенной строке (или после / перед всеми 
строками, если count превышает количество доступных строк).
RELATIVE 0 , FORWARD 0 и BACKWARD 0 - все запросы, выбирающие текущую строку без перемещения курсора, 
то есть повторную выборку самой последней выбранной строки. Это будет успешным, если курсор не будет 
находиться перед первой строкой или после последней строки; в этом случае строка не возвращается.

Parameters
direction определяет направление выборки и количество строк для выборки. Это может быть одно из следующих 
значений:
NEXT Выбрать следующую строку. Это значение по умолчанию, если direction не указано .
PRIOR Принесите предыдущий ряд.
FIRST Получите первую строку запроса (то же самое, что и ABSOLUTE 1 ).
LAST Получить последнюю строку запроса (то же самое, что и ABSOLUTE -1 ).
ABSOLUTE count Извлечь строку count запроса или строку abs(count) с конца, если count отрицательное. 
Позиционировать перед первой строкой или после последней строки, если count вне допустимого диапазона;
 в частности, ABSOLUTE 0 позиций перед первой строкой.
RELATIVE count Извлекает count 'последующий ряд - й, или abs(count) -й строки , если предшествующий 
count является отрицательным. RELATIVE 0 повторно выбирает текущую строку, если таковая имеется.
count Извлечь следующие строки count (так же, как FORWARD count ).
ALL Получить все оставшиеся строки (как FORWARD ALL ).
FORWARD Выбрать следующую строку (как NEXT ).
FORWARD count Получите следующие строки count . FORWARD 0 повторно выбирает текущую строку.
FORWARD ALL Соберите все оставшиеся ряды.
BACKWARD Получить предыдущую строку (то же, что и PRIOR ).
BACKWARD count Получить предыдущие строки count (сканирование назад). BACKWARD 0 повторно выбирает 
текущую строку. 
BACKWARD ALL Возьмите все предыдущие ряды (сканирование в обратном направлении).
count count - это, возможно, целочисленная константа со знаком, определяющая местоположение или 
количество строк для выборки. Для случаев FORWARD и BACKWARD указание отрицательного count 
эквивалентно изменению смысла FORWARD и BACKWARD .
cursor_name Имя открытого курсора.
Outputs При успешном завершении команда FETCH возвращает тег команды в форме
FETCH count count это количество выбранных строк (возможно , ноль). Обратите внимание, что в psql тег 
команды фактически не отображается, поскольку вместо этого psql отображает выбранные строки.
Notes Курсор должен быть объявлен с опцией SCROLL , если кто-то намеревается использовать любые варианты
 FETCH , кроме FETCH NEXT или FETCH FORWARD с положительным счетчиком. Для простых запросов PostgreSQL
 разрешит обратную выборку из курсоров, не объявленных с помощью SCROLL , но на такое поведение лучше 
не полагаться. Если курсор объявлен с NO SCROLL , обратная выборка не разрешена.
ABSOLUTE выборка не быстрее, чем переход к желаемой строке с относительным перемещением: базовая 
реализация в любом случае должна пройти все промежуточные строки. Отрицательные абсолютные выборки 
еще хуже: запрос нужно прочитать до конца, чтобы найти последнюю строку, а затем пройти оттуда в обратном 
направлении. Однако возврат к началу запроса (как и в случае FETCH ABSOLUTE 0 ) выполняется быстро.
DECLARE используется для определения курсора. Используйте MOVE , чтобы изменить положение курсора без 
извлечения данных.


moves=# select * from films;
 id |           name_film            |    type_film    |  production_company
----+--------------------------------+-----------------+----------------------
  1 | Nimona                         | Animation       | 20th Century Studios
  2 | The Tigers Apprentice          | Animation       | Paramount Pictures
  3 | Sesame Street                  | Comedy          | Warner Bros.
  4 | Minecraft                      | Action          | Warner Bros.
  5 | Spider-Man                     | Animation       | Sony Pictures
  6 | Aquaman 2                      | Action          | Warner Bros.
  7 | Black Panther: Wakanda Forever | Science fiction | Disney

BEGIN WORK;

- Установите курсор:
DECLARE liahona SCROLL CURSOR FOR SELECT * FROM films;

- Получить первые 3 строк в лиахоне курсора:
FETCH FORWARD 3 FROM liahona;

 id |       name_film       | type_film |  production_company
----+-----------------------+-----------+----------------------
  1 | Nimona                | Animation | 20th Century Studios
  2 | The Tigers Apprentice | Animation | Paramount Pictures
  3 | Sesame Street         | Comedy    | Warner Bros.

- Получить предыдущую строку:

FETCH PRIOR FROM liahona;
id |       name_film       | type_film | production_company
----+-----------------------+-----------+--------------------
  2 | The Tigers Apprentice | Animation | Paramount Pictures

- Закройте курсор и завершите транзакцию:
CLOSE liahona;
COMMIT WORK;


Compatibility
Стандарт SQL определяет FETCH для использования только во встроенном SQL. Описанный здесь вариант 
FETCH возвращает данные, как если бы это был результат SELECT , а не помещал их в переменные хоста.
 Помимо этого пункта, FETCH полностью совместим со стандартом SQL.
В FETCH формы с участием FORWARD и BACKWARD , а также формы FETCH count и FETCH ALL , в котором 
FORWARD подразумевается, являются расширениями PostgreSQL.
Стандарт SQL допускает только FROM перед именем курсора; возможность использовать IN или вообще 
исключить их - это расширение.

TRUNCATE-очистить таблицу или набор таблиц

Synopsis
TRUNCATE [ TABLE ] [ ONLY ] name [ * ] [, ... ]
    [ RESTART IDENTITY | CONTINUE IDENTITY ] [ CASCADE | RESTRICT ]
Description
TRUNCATE быстро удаляет все строки из набора таблиц. Он имеет тот же эффект, что и неквалифицированное
 удаление DELETE для каждой таблицы, но, поскольку он фактически не сканирует таблицы, он работает быстрее.
 Более того, он немедленно освобождает дисковое пространство, а не требует последующей операции VACUUM .
 Это наиболее полезно для больших таблиц.

Parameters
name Имя (возможно, дополненное схемой) таблицы для усечения. Если перед именем таблицы указано ONLY 
усекается  только эта таблица. Если ONLY не указан, таблица и все ее дочерние таблицы (если есть) усекаются. 
При желании после имени таблицы можно указать * , чтобы явно указать, что включены дочерние таблицы.
RESTART IDENTITY Автоматический перезапуск последовательностей,принадлежащих столбцам усеченной таблицы 
(таблиц).
CONTINUE IDENTITY Не изменяйте значения последовательностей.По умолчанию.
CASCADE Автоматически обрезать все таблицы, имеющие ссылки внешнего ключа на любую из названных таблиц
 или на любые таблицы, добавленные в группу из-за CASCADE .
RESTRICT Отказ от усечения,если какая-либо из таблиц имеет ссылки с посторонними ключами из таблиц,
которые не перечислены в команде.По умолчанию.

Notes У вас должна быть привилегия TRUNCATE для таблицы, чтобы ее обрезать.

TRUNCATE приобретает ACCESS EXCLUSIVE замок на каждой таюлице, который блокирует все другие параллельные
 операции в таблице. Когда задана RESTART IDENTITY , любые последовательности, которые должны быть 
перезапущены, также блокируются исключительно. Если требуется одновременный доступ к таблице, вместо 
этого следует использовать команду DELETE .
TRUNCATE нельзя использовать для таблицы, имеющей ссылки по внешнему ключу из других таблиц, 
если только все такие таблицы не будут усечены в одной и той же команде. Проверка правильности 
в таких случаях потребует сканирования таблицы, и весь смысл в том, чтобы не делать этого. 
Опцию CASCADE можно использовать для автоматического включения всех зависимых таблиц, 
но будьте очень осторожны при использовании этой опции, иначе вы можете потерять данные,
 которые не собирались! В частности, обратите внимание, что когда таблица, подлежащая усечению, 
является секцией, одноуровневые секции остаются нетронутыми, но каскадирование происходит для
 всех ссылающихся таблиц и всех их секций без различия.
TRUNCATE не будет ON DELETE триггеры ON DELETE, которые могут существовать для таблиц. Но он будет 
срабатывать триггеры ON TRUNCATE . Если триггеры ON TRUNCATE определены для любой из таблиц, то 
все триггеры BEFORE TRUNCATE срабатывают до того, как произойдет какое-либо усечение, и все триггеры 
AFTER TRUNCATE срабатывают после выполнения последнего усечения и сброса любых последовательностей. 
Триггеры будут срабатывать в том порядке, в котором должны обрабатываться таблицы (сначала те, которые 
указаны в команде, а затем все, которые были добавлены из-за каскадирования).
TRUNCATE не является безопасным для MVCC. После усечения таблица будет казаться пустой для параллельных 
транзакций, если они используют моментальный снимок, сделанный до того, как произошло усечение.
TRUNCATE безопасен для транзакций по отношению к данным в таблицах: усечение будет безопасно отменено,
 если окружающая транзакция не зафиксируется.
Если задана RESTART IDENTITY , подразумеваемые операции ALTER SEQUENCE RESTART также 
выполняются транзакционно; то есть они будут отменены, если окружающая транзакция не зафиксируется. 
Имейте в виду, что если какие-либо дополнительные операции над перезапущенными последовательностями
 выполняются до отката транзакции, последствия этих операций для последовательностей будут currval() , 
но не их влияние на currval () ; то есть после транзакции currval() продолжит отражать последнее значение 
последовательности, полученное внутри неудачной транзакции, даже если сама последовательность может больше 
не соответствовать этому. Это похоже на обычное поведение currval() после неудачной транзакции.
TRUNCATE может использоваться для сторонних таблиц, если поддерживается оболочкой сторонних данных, 
например, см. Postgres_fdw .

Examples
bigtable таблицы bigtable и fattable :

TRUNCATE bigtable, fattable;
То же самое,а также сбросить все связанные с ними генераторы последовательности:

TRUNCATE bigtable, fattable RESTART IDENTITY;
othertable таблицу othertable и выполните каскадирование к любым таблицам, которые ссылаются 
на othertable через ограничения внешнего ключа:
TRUNCATE othertable CASCADE;